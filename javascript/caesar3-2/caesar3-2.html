<html>
<head>
<script src="https://code.jquery.com/jquery-3.4.1.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script>
<style>
body {
    background-color: ivory;
}
canvas {
    //border:1px solid red;
}

.center {
  //margin: auto;
  width: 50%;
  //border: 3px solid green;
  padding: 10px;
}
</style>
</head>
<body>
    <img id="img-water1" src="assets/caesar2-water1.png" style="display: none;">
<p>Move, press and release the mouse</p>
<p id="downlog">Down</p>
<p id="movelog">Move</p>
<p id="uplog">Up</p>
<p id="outlog">Out</p>
<div class="center">
    <canvas id="canvas" width=800 height=600></canvas>
</div>
TODOs<br>
move scripts outside the html, have a js file<br>
do the Global Offset stuff for map moving<br>
do the water tile show at the correct location<br>
do all point variables be dicts with x and y attributes<br>
</fieldset>
<script>
var canvas = document.getElementById("canvas");
var context = canvas.getContext("2d");
var width = canvas.width;
var height = canvas.height;

var canvasOffset = $("#canvas").offset();
var offsetX = canvasOffset.left;
var offsetY = canvasOffset.top;

var globalOffsetX = 340;
var globalOffsetY = 140;
var globalOffsetMoveDirection = 0; // 1 - right; 2 - left; 3 - up; 4 - down
var stepGlobalMoving = {x: 0, y: 0};

var mouseX; // ???
var mouseY; // ???
var mousePressed = false; //

var game = new Game();

function handleMouseDown(e) {
    mouseX = parseInt(e.clientX - offsetX);
    mouseY = parseInt(e.clientY - offsetY);
    $("#downlog").html("Down: " + mouseX + " / " + mouseY);

    mousePressed = true;
}

function handleMouseUp(e) {
    mouseX = parseInt(e.clientX - offsetX);
    mouseY = parseInt(e.clientY - offsetY);
    $("#uplog").html("Up: " + mouseX + " / " + mouseY);

    mousePressed = false;
}

function handleMouseOut(e) {
    mouseX = parseInt(e.clientX - offsetX);
    mouseY = parseInt(e.clientY - offsetY);
    $("#outlog").html("Out: " + mouseX + " / " + mouseY);
    if (mouseX <= 0) {
        console.log('moving to the left of the board');
        globalOffsetMoveDirection = 2;
        stepGlobalMoving.x = -1;
        stepGlobalMoving.y = 0;
    }
    if (mouseX >= 800) {
        console.log('moving to the right of the board');
        globalOffsetMoveDirection = 1;
        stepGlobalMoving.x = 1;
        stepGlobalMoving.y = 0;
    }
    if (mouseY <= 0) {
        console.log('moving up the board');
        globalOffsetMoveDirection = 3;
        stepGlobalMoving.x = 0;
        stepGlobalMoving.y = 1;
    }
    if (mouseY >= 600) {
        console.log('moving down the board');
        globalOffsetMoveDirection = 4;
        stepGlobalMoving.x = 0;
        stepGlobalMoving.y = -1;
    }
}

function handleMouseMove(e) {
    mouseX = parseInt(e.clientX - offsetX);
    mouseY = parseInt(e.clientY - offsetY);
    $("#movelog").html("Move: " + mouseX + " / " + mouseY);
    globalOffsetMoveDirection = 0;
    stepGlobalMoving.x = 0;
    stepGlobalMoving.y = 0;
}

$("#canvas").mousedown(function (e) {
    handleMouseDown(e);
});
$("#canvas").mousemove(function (e) {
    handleMouseMove(e);
});
$("#canvas").mouseup(function (e) {
    handleMouseUp(e);
});
$("#canvas").mouseout(function (e) {
    handleMouseOut(e);
});

window.onload = function () {
    init();
    setInterval(update, 1000/30);
    //setInterval(update, 2000); // debug only
}

function init() {
    console.log("running init()");
    game.init();
}

function update() {
    //console.log("updating");
    //console.log(mouseX + " x " + mouseY);
    game.clear();
    game.changeGlobalOffsetParams();
    game.drawGrid();
}

function Game () {
    this.cameraOffset = {x: 0, y: 0};
}

Game.prototype.init = function () {
    console.log('Game init...');
    var i, j;
    this.grid = new Array(10);
    /*for(i = 0; i < this.grid.length; i++) {
        this.grid[i] = new Array(10);
    }
    for (i = 0; i < this.grid.length; i++) {
        for (j = 0; j < this.grid[i].length; j++) {
            this.grid[i][j] = 0;
        }
    }*/
    this.grid = [
        [1, 0, 0, 0, 1, 0, 0, 1, 1, 1],
        [0, 0, 0, 0, 1, 1, 0, 1, 1, 0],
        [0, 0, 0, 0, 0, 1, 0, 1, 1, 0],
        [0, 0, 0, 0, 0, 0, 1, 1, 1, 1],
        [0, 0, 0, 0, 0, 0, 0, 1, 1, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 1, 1, 0, 0, 0, 0, 0, 0, 0],
        [0, 1, 0, 0, 0, 0, 0, 0, 0, 1],
        [0, 1, 1, 1, 0, 0, 0, 0, 0, 0],
        [0, 1, 1, 0, 0, 0, 0, 0, 0, 0]
    ];
}

Game.prototype.drawGrid = function () {
    var i, j;
    for (i = 0; i < this.grid.length; i++) {
        for (j = 0; j < this.grid[i].length; j++) {
            drawRombBorder(j, i); // draw row x col y: (0,0) ; (1,0) ; (2, 0)
        }
        //break;
    }
}

Game.prototype.changeGlobalOffsetParams = function () {
    switch(globalOffsetMoveDirection) {
        case 1:
            if (stepGlobalMoving.x < 8) stepGlobalMoving.x -= 1; // initial *= 2 ; apoi += 2
            if (globalOffsetX > 240) {
                updateGlobalOffsetPoint();
            }
        break;
        case 2:
            if (stepGlobalMoving.x > -8) stepGlobalMoving.x += 1; // initial *= 2 ; apoi += 2
            if (globalOffsetX < 440) {
                updateGlobalOffsetPoint();
            }
        break;
        case 3:
            if (stepGlobalMoving.y < 8) stepGlobalMoving.y += 1; // initial *= 2 ; apoi += 2
            if (globalOffsetY < 180) {
                updateGlobalOffsetPoint();
            }
        break;
        case 4:
            if (stepGlobalMoving.y > -8) stepGlobalMoving.y -= 1; // initial *= 2 ; apoi += 2
            if (globalOffsetY > 100) {
                updateGlobalOffsetPoint();
            }
        break;
    }
}

Game.prototype.clear = function () {
    context.beginPath();
    context.fillStyle = "black"; //"#556655";
    context.rect(0, 0, width, height);
    context.fill();
}

function updateGlobalOffsetPoint() {
    if (globalOffsetMoveDirection) {
        globalOffsetX += stepGlobalMoving.x;
        globalOffsetY += stepGlobalMoving.y;
    }
}

function getSquareFromPhisicalPosition(pointX, pointY) {
    var logicalPosition = {};
    return logicalPosition;
}

function drawRombBorder(i, j) {
    // trebuie puse variabile si parametrizat
    var halfWidth = 30;
    var halfHeight = 15;
    //if (i == 0 && j == 0) {
    if (game.grid[i][j] == 1) {
        var img = document.getElementById("img-water1");
        var tileOffsetX = globalOffsetX + i * halfWidth - j * halfWidth;
        var tileOffsetY = globalOffsetY + i * halfHeight + (j - 1) * halfHeight;
        context.drawImage(img, tileOffsetX, tileOffsetY);
        // draw the water romb image
        return;
    }
    var rombOffsetX = globalOffsetX + i * halfWidth - j * halfWidth;
    var rombOffsetY = globalOffsetY + i * halfHeight + j * halfHeight;
    if (mouseHoverRomb(rombOffsetX, rombOffsetY)) {
        context.fillStyle = 'green';
    } else {
        if ((i + j) % 2 == 0)
            context.fillStyle = 'gray';
        else
            context.fillStyle = 'lightgrey';
    }
    context.beginPath();
    context.moveTo(rombOffsetX, rombOffsetY);
    context.lineTo(rombOffsetX + halfWidth, rombOffsetY + halfHeight);
    context.lineTo(rombOffsetX + halfWidth * 2, rombOffsetY);
    context.lineTo(rombOffsetX + halfWidth, rombOffsetY - halfHeight);
    context.closePath();
    context.fill();
}

function mouseHoverRomb(rombOffsetX, rombOffsetY) {
    var halfWidth = 30;
    var halfHeight = 15;

    var point = {x: mouseX, y: mouseY};
    var a = {x: rombOffsetX, y: rombOffsetY};
    var b = {x: rombOffsetX + halfWidth - 1, y: rombOffsetY + halfHeight}; // am pus -1 ca sa nu fac overlap
    var c = {x: rombOffsetX + halfWidth * 2 - 1, y: rombOffsetY}; // am pus -1 ca sa nu fac overlap
    var d = {x: rombOffsetX + halfWidth - 1, y: rombOffsetY - halfHeight}; // am pus -1 ca sa nu fac overlap
    return checkIfPointInsideTriangle(point, a, b, c) || checkIfPointInsideTriangle(point, a, c, d);
}

function checkIfPointInsideTriangle(s, a, b, c) {
    var as_x = s.x-a.x;
    var as_y = s.y-a.y;

    var s_ab = (b.x-a.x)*as_y-(b.y-a.y)*as_x > 0;
    if((c.x-a.x)*as_y-(c.y-a.y)*as_x > 0 == s_ab) return false;
    if((c.x-b.x)*(s.y-b.y)-(c.y-b.y)*(s.x-b.x) > 0 != s_ab) return false;
    return true;
}

</script>
</body>
</html>